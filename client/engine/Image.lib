#!/bin/bash
#/**
#@file    Image.lib
#@brief   Librería o clase Image
#@class   Image
#@brief   Funciones para creación, restauración y clonación de imágenes de sistemas.
#@version 1.1.0
#@warning License: GNU GPLv3+
#*/


#/**
#         ogCreateImageSyntax path_device path_filename [str_tool] [str_compressionlevel]
#@brief   Genera una cadena de texto con la instrucción para crear un fichero imagen
#@param   path_device           dispositivo Linux del sistema de archivos
#@param   path_fileneme         path absoluto del fichero imagen
#@param   [opcional] str_tool   herrmaienta de clonacion [partimage, partclone, ntfsclone]
#@param   [opcional] str_compressionlevel nivel de compresion. [0 -none-, 1-lzop-, 2-gzip]
#@return  str_command - cadena con el comando que se debe ejecutar.
#@warning Salida nula si se producen errores.
#@TODO    introducir las herramientas fsarchiver, dd
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#@version 1.0.5 - Incrustar códico de antigua función ogPartcloneSyntax
#@author  Ramon Gomez, ETSII Universidad de Sevilla 
#@date    2012/09/14
#*/ ##
function ogCreateImageSyntax()
{
local FS TOOL LEVEL DEV IMGFILE BUFFER PARAM1 PARAM2 PARAM3

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_device path_imagefile [str_tool] [str_compressionlevel]" \
           "$FUNCNAME /dev/sda1 /opt/opengnsys/images/prueba.img partclone lzop" \
           "$FUNCNAME /dev/sda1 /opt/opengnsys/images/prueba.img"
    return
fi
# Error si no se reciben entre 2 y 4 parámetros.
[ $# -ge 2 -a $# -le 4 ] || ogRaiseError $OG_ERR_FORMAT "$*" || return $?

# Asignación de parámetros.
DEV="$1"
IMGFILE="$2"
case "$#" in
    2)  # Sintaxis por defecto OG DEV IMGFILE
        TOOL="partclone"
        LEVEL="gzip"
        ;;
    4)  # Sintaxis condicionada.
        TOOL="${3,,}"
        LEVEL="${4,,}"
        ;;
esac

case "$TOOL" in
    ntfsclone)
        PARAM1="ntfsclone --force --save-image -O - $DEV"
        ;;
    partimage|default)
        PARAM1="partimage -M -f3 -o -d -B gui=no -c -z0 --volume=0 save $DEV stdout"
        ;;
    partclone)
        FS="$(ogGetFsType $(ogDevToDisk $DEV 2>/dev/null) 2>/dev/null)"
        case "$FS" in
            EXT[234]) PARAM1="partclone.extfs" ;;
            BTRFS)    PARAM1="partclone.btrfs" ;;
            REISERFS) PARAM1="partclone.reiserfs" ;;
            REISER4)  PARAM1="partclone.reiser4" ;;
            JFS)      PARAM1="partclone.jfs" ;;
            XFS)      PARAM1="partclone.xfs" ;;
            F2FS)     PARAM1="partclone.f2fs" ;;
            NILFS2)   PARAM1="partclone.nilfs2" ;;
            NTFS)     PARAM1="partclone.ntfs" ;;
            EXFAT)    PARAM1="partclone.exfat" ;;
            FAT16|FAT32) PARAM1="partclone.fat" ;;
            HFS|HFSPLUS) PARAM1="partclone.hfsp" ;;
            UFS)      PARAM1="partclone.ufs" ;;
            VMFS)     PARAM1="partclone.vmfs" ;;
            *)        PARAM1="partclone.imager" ;;
        esac
        # Por compatibilidad, si no existe el ejecutable usar por defecto "parclone.dd".
        which $PARAM1 &>/dev/null || PARAM1="partclone.dd"
        PARAM1="$PARAM1 -d0 -F -c -s $DEV"
        # Algunas versiones de partclone.dd no tienen opción "-c".
        [ -z "$(eval ${PARAM1%% *} --help 2>&1 | grep -- -c)" ] && PARAM1="${PARAM1/ -c / }"
        ;;
esac
# Comprobar que existe mbuffer.
which mbuffer &>/dev/null && PARAM2="| mbuffer -q -m 40M " || PARAM2=" "

# Nivel de compresion.
case "$LEVEL" in
    0|none) PARAM3=" > " ;;
    1|lzop) PARAM3=" | lzop > " ;;
    2|gzip) PARAM3=" | gzip -c > " ;;
    3|bzip) PARAM3=" | bzip -c > " ;;
esac

# Sintaxis final.
[ -n "$PARAM1" ] && echo "$PARAM1 $PARAM2 $PARAM3 $IMGFILE"
}


#/**
#         ogRestoreImageSyntax path_filename path_device [str_tools] [str_compressionlevel]
#@brief   Genera una cadena de texto con la instrucción para crear un fichero imagen
#@param   path_device           dispositivo Linux del sistema de archivos
#@param   path_fileneme         path absoluto del fichero imagen
#@param   [opcional] str_tools  herrmaienta de clonacion [partimage, partclone, ntfsclone]
#@param   [opcional] str_compressionlevel nivel de compresion. [0 -none-, 1-lzop-, 2-gzip]
#@return  cadena con el comando que se debe ejecutar.
#@exception OG_ERR_FORMAT    formato incorrecto.
#@warning En pruebas iniciales
#@TODO    introducir las herramientas fsarchiver, dd
#@TODO    introducir el nivel de compresion gzip
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##
function ogRestoreImageSyntax ()
{
local TOOL COMPRESSOR LEVEL PART IMGFILE FILEHEAD INFOIMG


# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME  filename partition [tool] [levelcompresor]" \
           "$FUNCNAME  /opt/opengnsys/images/prueba.img /dev/sda1 [partclone] [lzop]"
    return
fi

# Error si no se reciben entre 2 y 4 parámetros.
[ $# -ge 2 -a $# -le 4 ] || ogRaiseError $OG_ERR_FORMAT "$*" || return $?

# controlamos que el parametro 1 (imagen) es tipo file.
[ -f $1 ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?

# Si 2 parametros (file-origen-, device-destino-) = ogGetImageFull($1)
if [ "$#" -eq 2 ]; then
	IMGFILE=$1
	PART=$2
	INFOIMG=$(ogGetImageInfo $IMGFILE) || ogRaiseError $OG_ERR_NOTFOUND "No Image $1" || return $?
	TOOL=`echo $INFOIMG | cut -f1 -d:`
	COMPRESSOR=`echo $INFOIMG | cut -f2 -d:`
	ogRestoreImageSyntax $IMGFILE $PART $TOOL $COMPRESSOR
fi


# Si cuatro parametros genera sintaxis
if [ "$#" -eq 4 ]; then
	IMGFILE=$1
	PART=$2 
	# comprobamos parametro herramienta compresion.
	TOOL=$(echo $3 | tr [A-Z] [a-z])	
	#ogCheckProgram $TOOL
	#comprobar parámetro compresor.
	LEVEL=$(echo $4 | tr [A-Z] [a-z])
	#ogCheckProgram $LEVEL
	
	case "$LEVEL" in
    	"0"|"none")
    		COMPRESSOR=" "
    	;;
    	"1"|"lzop" | "LZOP")
    		COMPRESSOR=" lzop -dc "
    	;;
    	"2"|"gzip" | "GZIP")
    		COMPRESSOR=" gzip -dc "
    	;;
    	"3"|"bzip" | "BZIP" )
    		COMPRESSOR=" bzip -dc "
    	;;
    	*)
    		ogRaiseError $OG_ERR_NOTFOUND "Compressor no valid $TOOL" || return $?
    	;;
	esac
    #comprobar mbuffer
	which mbuffer > /dev/null && MBUFFER="| mbuffer -q -m 40M " || MBUFFER=" "

	case "${TOOL,,}" in
		ntfsclone)
			TOOL="| ntfsclone --restore-image --overwrite $PART -"
		;;
		partimage)
			TOOL="| partimage -f3 -B gui=no restore $PART stdin"
		;;
		partclone*)
		    # -C para que no compruebe tamaños
			TOOL="| partclone.restore -d0 -C -I -o $PART"
		;;
                dd)
                        TOOL="| pv | dd conv=sync,noerror bs=1M of=$PART"
		;;
		*)
    		ogRaiseError $OG_ERR_NOTFOUND "Tools imaging no valid $TOOL" || return $?
    	;;
	esac

	echo "$COMPRESSOR $IMGFILE $MBUFFER $TOOL"
fi

}




#/**
#         ogCreateDiskImage int_ndisk str_repo path_image [str_tools] [str_compressionlevel]
#@brief   Crea una imagen (copia de seguridad) de un disco completo.
#@param   int_ndisk      nº de orden del disco
#@param   str_repo       repositorio de imágenes (remoto o caché local)
#@param   path_image     camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@note    Esta primera versión crea imágenes con dd comprimidas con gzip.
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_LOCKED    particion bloqueada por otra operación.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@warning En pruebas iniciales
#@todo    Gestión de bloqueos de disco
#@todo    Comprobar si debe desmontarse la caché local
#@todo    Comprobar que no se crea la imagen en el propio disco
#@version 1.1.0 -  Primera versión para OpenGnsys con herramientas prefijadas.
#@author  Ramon Gomez, ETSII Universidad de Sevilla 
#@Date    2016/04/08
#*/ ##
function ogCreateDiskImage ()
{
# Variables locales
local DISK PROGRAM IMGDIR IMGFILE IMGTYPE ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk str_repo path_image" \
           "$FUNCNAME 1 REPO /disk1"
    return
fi
# Error si no se reciben entre 3 y 5 parámetros.
[ $# -ge 3 -a $# -le 5 ] || ogRaiseError $OG_ERR_FORMAT "$*" || return $?

# Comprobar que no está bloqueada ni la partición, ni la imagen.
DISK="$(ogDiskToDev $1)" || return $?
if ogIsDiskLocked $1; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_LOCKED $1"
    return $?
fi
IMGTYPE="dsk"			# Extensión genérica de imágenes de disco.
IMGDIR=$(ogGetParentPath "$2" "$3")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$2 $(dirname $3)" || return $?
IMGFILE="$IMGDIR/$(basename "$3").$IMGTYPE"
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $3, $4"
    return $?
fi

# No guardar imagen en el propio disco (disco no incluido en el camino del repositorio).
if [[ $(ogGetPath "$2" /) =~ ^$DISK ]]; then
    ogRaiseError $OG_ERR_IMAGE "$2 = $DISK"
    return $?
fi

# Generar la instruccion a ejecutar antes de aplicar los bloqueos.
PROGRAM=$(ogCreateImageSyntax $DISK $IMGFILE)
# Desmontar todos los sistemas de archivos del disco, bloquear disco e imagen.
ogUnmountAll $1 2>/dev/null
ogLockDisk $1 || return $?
ogLockImage "$2" "$3.$IMGTYPE" || return $?

# Crear Imagen.
trap "ogUnlockDisk $1; ogUnlockImage "$3" "$4.$IMGTYPE"; rm -f $IMGFILE" 1 2 3 6 9
eval $PROGRAM

# Controlar salida de error, crear fichero de información y desbloquear partición.
ERRCODE=$?
if [ $ERRCODE == 0 ]; then
    echo "$(ogGetImageInfo $IMGFILE):$(ogGetHostname)" > $IMGFILE.info
else
    ogRaiseError $OG_ERR_IMAGE "$1 $2 $IMGFILE"
    rm -f "$IMGFILE"
fi
# Desbloquear disco e imagen.
ogUnlockDisk $1
ogUnlockImage "$2" "$3.$IMGTYPE"
return $ERRCODE
}


#/**
#         ogCreateImage int_ndisk int_npartition str_repo path_image [str_tools] [str_compressionlevel]
#@brief   Crea una imagen a partir de una partición.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@param   str_repo       repositorio de imágenes (remoto o caché local)
#@param   path_image     camino de la imagen (sin extensión)
#@param   [opcional] str_tools  herrmaienta de clonacion [partimage, partclone, ntfsclone]
#@param   [opcional] str_compressionlevel nivel de compresion. [0 -none-, 1-lzop-, 2-gzip]
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_PARTITION partición no accesible o no soportada.
#@exception OG_ERR_LOCKED    particion bloqueada por otra operación.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@todo    Comprobaciones, control de errores, definir parámetros, etc.
#@version 0.1 -  Integracion para Opengnsys  -  HIDRA:CrearImagen{EXT3, NTFS}.sh;  EAC: CreateImageFromPartition () en Deploy.lib
#@author  Ramon Gomez, ETSII Universidad de Sevilla 
#@Date    2008/05/13
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008/10/27
#@version 0.9 - Versión en pruebas para OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/10/07
#@version 1.0 - Llama a función ogCreateImageSyntax para generar la llamada al comando.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##
function ogCreateImage ()
{
# Variables locales
local PART PROGRAM IMGDIR IMGFILE IMGTYPE ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npart str_repo path_image" \
           "$FUNCNAME 1 1 REPO /aula1/win7"
    return
fi
# Error si no se reciben entre 4 y 6 parámetros.
[ $# -ge 4 -a $# -le 6 ] || ogRaiseError $OG_ERR_FORMAT "$*" || return $?

# Comprobar que no está bloqueada ni la partición, ni la imagen.
PART="$(ogDiskToDev $1 $2)" || return $?
if ogIsLocked $1 $2; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_LOCKED $1, $2"
    return $?
fi

IMGTYPE="img"			# Extensión genérica de imágenes.
IMGDIR=$(ogGetParentPath "$3" "$4")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$3 $(dirname $4)" || return $?

IMGFILE="$IMGDIR/$(basename "$4").$IMGTYPE"
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $3, $4"
    return $?
fi
# Generar la instruccion a ejecutar antes de aplicar los bloqueos.
PROGRAM=$(ogCreateImageSyntax $PART $IMGFILE $5 $6)
# Desmontar partición, bloquear partición e imagen.
ogUnmount $1 $2 2>/dev/null
ogLock $1 $2 || return $?
ogLockImage "$3" "$4.$IMGTYPE" || return $?

# Crear Imagen.
trap "ogUnlock $1 $2; ogUnlockImage "$3" "$4.$IMGTYPE"; rm -f $IMGFILE" 1 2 3 6 9
eval $PROGRAM

# Controlar salida de error, crear fichero de información y desbloquear partición.
ERRCODE=$?
if [ $ERRCODE == 0 ]; then
    echo "$(ogGetImageInfo $IMGFILE):$(ogGetHostname)" > $IMGFILE.info
    cp -f $IMGFILE.info /tmp/image.info
else
    ogRaiseError $OG_ERR_IMAGE "$1 $2 $IMGFILE"
    rm -f "$IMGFILE"
fi
# Desbloquear partición e imagen.
ogUnlock $1 $2
ogUnlockImage "$3" "$4.$IMGTYPE"
return $ERRCODE
}


#/**
#         ogCreateMbrImage int_ndisk str_repo path_image
#@brief   Crea una imagen a partir del sector de arranque de un disco.
#@param   int_ndisk    nº de orden del disco
#@param   str_repo     repositorio de imágenes (remoto o caché local)
#@param   path_image   camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@version 0.9 - Versión en pruebas para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010/01/12
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogCreateMbrImage ()
{
# Variables locales
local DISK IMGDIR IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk str_repo path_image" \
           "$FUNCNAME 1 REPO /aula1/mbr"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?

DISK=$(ogDiskToDev "$1") || return $?
IMGDIR=$(ogGetParentPath "$2" "$3")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$2 $(dirname $3)" || return $?
IMGFILE="$IMGDIR/$(basename "$3").mbr"

# Crear imagen del MBR.
dd if="$DISK" of="$IMGFILE" bs=512 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}


#/**
#         ogCreateBootLoaderImage int_ndisk str_repo path_image
#@brief   Crea una imagen del boot loader a partir del sector de arranque de un disco.
#@param   int_ndisk    nº de orden del disco
#@param   str_repo     repositorio de imágenes (remoto o caché local)
#@param   path_image   camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@version 1.0 - Adaptacion de ogCreateMbrImage para guardar solo el Boot Loader
#@author  Juan Carlos Xifre, SICUZ Universidad de Zaragoza
#@date    2011/03/21
#*/ ##
function ogCreateBootLoaderImage ()
{
# Variables locales
local DISK IMGDIR IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk str_repo path_image" \
           "$FUNCNAME 1 REPO /aula1/mbr"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?

DISK=$(ogDiskToDev "$1") || return $?
IMGDIR=$(ogGetParentPath "$2" "$3")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$2 $(dirname $3)" || return $?
IMGFILE="$IMGDIR/$(basename "$3").mbr"

# Crear imagen del Boot Loader dentro del MBR.
dd if="$DISK" of="$IMGFILE" bs=446 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}

#/**
#         ogGetSizeParameters int_num_disk  int_num_part str_repo [monolit|sync|diff]
#@brief   Devuelve el tamaño de los datos de un sistema de ficheros, el espacio necesario para la imagen y si cabe en el repositorio elegido.
#@param   int_disk     numero de disco
#@param	  int_part     numero de particion 
#@param   str_repo     repositorio de imágenes   { REPO, CACHE }
#@param   str_imageName Nombre de la imagen
#@param   str_imageType Tipo de imagen: monolit (por defecto), sync o diff. (parametro opcional) 
#@return  SIZEDATA SIZEREQUIRED SIZEFREE ISENOUGHSPACE 
#@note    si str_imageType= diff necesario /tmp/ogimg.info, que es creado por ogCreateInfoImage.
#@note    para el tamaño de la imagen no sigue enlaces simbólicos.
#@exception OG_ERR_FORMAT    formato incorrecto.
#@author  Irina Gomez, ETSII Universidad de Sevilla
#@date    2014/10/24
#@version 1.1.0 - En la salida se incluye el espacio disponible en el repositorio (ticket #771)
#@author  Irina Gomez - ETSII Universidad de Sevilla
#@date    2017-03-28
#@version 1.1.0 - Si la imagen ya existe en el REPO se suma su tamaño al espacio libre
#@author  Irina Gomez - ETSII Universidad de Sevilla
#@date    2017-11-08
#*/ ##
function ogGetSizeParameters ()
{
local REPO MNTDIR SIZEDATA KERNELVERSION SIZEREQUIRED FACTORGZIP FACTORLZOP FACTORSYNC SIZEFREE 
local IMGTYPE IMGDIR IMGFILE IMGEXT IMGSIZE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME num_disk num_part str_repo path_imgname [monolit|sync|diff]" \
           "if $FUNCNAME 1 2 REPO Windows10 sync ; then ...; fi" \
           "if $FUNCNAME 1 6 Ubuntu16 CACHE ; then ...; fi" 
    return
fi
# Error si no se reciben 1 o 2 parámetros.
[ $# -lt 4 ] && return $(ogRaiseError session $OG_ERR_FORMAT "$MSG_FORMAT: $PROG ndisco nparticion REPO|CACHE imgname [monolit|sync|diff]" ; echo $?)

# Recogemos parametros
REPO=${3^^}
IMGTYPE="_${5^^}_"

MNTDIR=$(ogMount $1 $2)
if [ "$MNTDIR" == "" ]; then
    ogRaiseError $OG_ERR_PARTITION "$1 $2"
    return $?
fi

# Datos contenidos en la particion o en la lista de archivos de contiene la diferencial.
if [ "$IMGTYPE" == "_DIFF_" ]; then
	[ -r /tmp/ogimg.info ] || return $(ogRaiseError session $OG_ERR_NOTFOUND "/tmp/ogimg.info"; echo $?)
	cd $MNTDIR
	SIZEDATA=$(grep -v "\/$" /tmp/ogimg.info | tr '\n' '\0'| du -x -c --files0-from=- 2>/dev/null|tail -n1 |cut -f1)
	cd /
else
	SIZEDATA=$(df -k | grep $MNTDIR\$ | awk '{print $3}')
fi

#Aplicar factor de compresion
if [ "$IMGTYPE" == "_SYNC_" -o "$IMGTYPE" == "_DIFF_" ]; then
	
	# Sistema de fichero de la imagen según kernel, menor que 3.7 EXT4. comparamos revision 
	KERNELVERSION=$(uname -r| awk '{printf("%d",$1);sub(/[0-9]*\./,"",$1);printf(".%02d",$1)}')
	[ $KERNELVERSION \< 3.07 ] &&  IMGFS="EXT4" || IMGFS=${IMGFS:-"BTRFS"}
	FACTORSYNC=${FACTORSYNC:-"130"}
	# Si IMGFS="BTRFS" la compresion es mayor.
	[ $IMGFS == "BTRFS" ] && let FACTORSYNC=$FACTORSYNC-20

	let SIZEREQUIRED=$SIZEDATA*$FACTORSYNC/100
	# El tamaño mínimo del sistema de ficheros btrfs es 250M, ponemos 300
	[ $SIZEREQUIRED -lt 300000 ] && SIZEREQUIRED=300000
	
else
	FACTORGZIP=55/100
	FACTORLZOP=65/100
	let SIZEREQUIRED=$SIZEDATA*$FACTORLZOP
fi

#Comprobar espacio libre en el contenedor.
[ "$REPO" == "CACHE" ] && SIZEFREE=$(ogGetFreeSize `ogFindCache`)
[ "$REPO" == "REPO" ] && SIZEFREE=$(df -k | grep $OGIMG | awk '{print $4}')

# Comprobamos si existe una imagen con el mismo nombre en $REPO
# En sincronizadas restamos tamaño de la imagen y en monoloticas de la .ant
case "${IMGTYPE}" in
    _DIFF_) IMGEXT="img.diff"
	    ;;
    _SYNC_) IMGEXT="img"
            ;;
    *)      IMGEXT="img.ant"
            ;;
esac

IMGDIR=$(ogGetParentPath "$REPO" "/$4")
IMGFILE=$(ogGetPath "$IMGDIR/$(basename "/$4").$IMGEXT")
if [ -z "$IMGFILE" ]; then
    IMGSIZE=0
else
    IMGSIZE=$(ls -s "$IMGFILE" | cut -f1 -d" ")
fi

let SIZEFREE=$SIZEFREE+$IMGSIZE

[ "$SIZEREQUIRED" -lt "$SIZEFREE" ] && ISENOUGHSPACE=TRUE  ||  ISENOUGHSPACE=FALSE

echo $SIZEDATA $SIZEREQUIRED $SIZEFREE $ISENOUGHSPACE

}

#/**
#         ogIsImageLocked [str_repo] path_image
#@brief   Comprueba si una imagen está bloqueada para uso exclusivo.
#@param   str_repo     repositorio de imágenes (opcional)
#@param   path_image   camino de la imagen (sin extensión)
#@return  Código de salida: 0 - bloqueado, 1 - sin bloquear o error.
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#@version 1.0.1 - Devolver falso en caso de error.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011-05-18
#*/ ##
function ogIsImageLocked ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_repo] path_image" \
           "if $FUNCNAME /opt/opengnsys/images/aula1/win7.img; then ...; fi" \
           "if $FUNCNAME REPO /aula1/win7.img; then ...; fi"
    return
fi
# Error si no se reciben 1 o 2 parámetros.
[ $# -lt 1 -o $# -gt 2 ] && return 1

# Comprobar si existe el fichero de bloqueo.
test -n "$(ogGetPath $@.lock)"
}


#/**
#         ogLockImage [str_repo] path_image
#@brief   Bloquea una imagen para uso exclusivo.
#@param   str_repo     repositorio de imágenes (opcional)
#@param   path_image   camino de la imagen (sin extensión)
#@return  Nada.
#@note    Se genera un fichero con extensión .lock
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogLockImage ()
{
# Variables locales
local IMGDIR

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_repo] path_image" \
           "$FUNCNAME /opt/opengnsys/images/aula1/win7.img" \
           "$FUNCNAME REPO /aula1/win7.img"
    return
fi
# Error si no se reciben 1 o 2 parámetros.
[ $# == 1 -o $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Comprobar que existe directorio de imagen
IMGDIR=$(ogGetParentPath $@) || return $?
# Crear fichero de bloqueo.
touch $IMGDIR/$(basename "${!#}").lock 2>/dev/null || ogRaiseError $OG_ERR_NOTWRITE "$*" || return $?
}


#/**
#         ogRestoreDiskImage str_repo path_image int_npartition
#@brief   Restaura (recupera) una imagen de un disco completo.
#@param   str_repo       repositorio de imágenes o caché local
#@param   path_image     camino de la imagen
#@param   int_ndisk      nº de orden del disco
#@return  (por determinar)
#@warning Primera versión en pruebas
#@todo    Gestionar bloqueos de disco
#@todo    Comprobar que no se intenta restaurar de la caché sobre el mismo disco
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero de imagen o partición no detectados.
#@exception OG_ERR_LOCKED    partición bloqueada por otra operación.
#@exception OG_ERR_IMAGE     error al restaurar la imagen del sistema.
#@exception OG_ERR_IMGSIZEPARTITION  Tamaño de la particion es menor al tamaño de la imagen.
#@version 1.1.0 - Primera versión para OpenGnsys.
#@author Ramon Gomez, ETSII Universidad de Sevilla 
#@Date    2016/04/08
#*/ ##
function ogRestoreDiskImage ()
{
# Variables locales
local DISK DISKSIZE IMGFILE IMGTYPE IMGSIZE PROGRAM ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str_repo path_image int_ndisk" \
           "$FUNCNAME REPO /aula1/win7 1"
    return
fi
# Error si no se reciben 4 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Procesar parámetros.
DISK="$(ogDiskToDev $3)" || return $(ogRaiseError $OG_ERR_NOTFOUND " $3 $4"; echo $?)
IMGTYPE="dsk"
IMGFILE=$(ogGetPath "$1" "$2.$IMGTYPE") 
[ -r "$IMGFILE" ] || return $(ogRaiseError $OG_ERR_NOTFOUND " $3 $4"; echo $?)

# comprobamos consistencia de la imagen
ogGetImageInfo $IMGFILE >/dev/null  || return $(ogRaiseError $OG_ERR_IMAGE " $1 $2"; echo $?)

#/* (Comienzo comentario Doxygen)
# Error si la imagen no cabe en la particion.
#IMGSIZE=$(ogGetImageSize "$1" "$2") || return $(ogRaiseError $OG_ERR_IMAGE " $1 $2"; echo $?)
#DISKSIZE=$(ogGetDiskSize $3)
#if [ $IMGSIZE -gt $DISKSIZE ]; then
#    ogRaiseError $OG_ERR_IMGSIZEPARTITION "$DISKSIZE < $IMGSIZE"
#    return $?
#fi
#*/ (Fin comentario Doxygen)

# Comprobar el bloqueo de la imagen y de la partición.
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $1, $2.$IMGTYPE"
    return $?
fi
if ogIsDiskLocked $3; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_DISK $3"
    return $?
fi
# Solicitamos la generación de la instruccion a ejecutar
PROGRAM=$(ogRestoreImageSyntax $IMGFILE $DISK)

# Bloquear el disco
ogLockDisk $3 || return $?
trap "ogUnlockDisk $3" 1 2 3 6 9

# Ejecutar restauración según el tipo de imagen.
eval $PROGRAM

ERRCODE=$?
if [ $ERRCODE != 0 ]; then
    ogRaiseError $OG_ERR_IMAGE "$IMGFILE, $3, $4"
fi
ogUnlockDisk $3 $4
return $ERRCODE
}


#/**
#         ogRestoreImage str_repo path_image int_ndisk int_npartition
#@brief   Restaura una imagen de sistema de archivos en una partición.
#@param   str_repo       repositorio de imágenes o caché local
#@param   path_image     camino de la imagen
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  (por determinar)
#@exception OG_ERR_FORMAT   1 formato incorrecto.
#@exception OG_ERR_NOTFOUND  2 fichero de imagen o partición no detectados.
#@exception OG_ERR_PARTITION 3	# Error en partición de disco.
#@exception OG_ERR_LOCKED    4 partición bloqueada por otra operación.
#@exception OG_ERR_IMAGE    5 error al restaurar la imagen del sistema.
#@exception OG_ERR_IMGSIZEPARTITION  30 Tamaño de la particion es menor al tamaño de la imagen.
#@todo    Comprobar incongruencias partición-imagen, control de errores, definir parámetros, caché/repositorio, etc.
#@version 0.1 -  Integracion para Opengnsys  - HIDRA:RestaurarImagen{EXT3, NTFS}.sh;  EAC: RestorePartitionFromImage() en Deploy.lib
#@author Ramon Gomez, ETSII Universidad de Sevilla 
#@Date    2008/05/13
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008/10/27
#@version 0.9 - Primera version muy en pruebas para OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/09/10
#@version 1.0 - generacion sintaxis de restauracion
#@author  Antonio J. Doblas Viso, Universidad de Malaga
#@date    2011/02/01
#@version 1.0.1 - Control errores, tamaño particion, fichero-imagen
#@author  Antonio J. Doblas Viso, Universidad de Malaga
#@date    2011/05/11
#*/ ##
function ogRestoreImage ()
{
# Variables locales
local PART PARTSIZE IMGFILE IMGTYPE IMGSIZE FSTYPE PROGRAM ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str_repo path_image int_ndisk int_npart" \
           "$FUNCNAME REPO /aula1/win7 1 1"
    return
fi
# Error si no se reciben 4 parámetros.
[ $# == 4 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Procesar parámetros.
PART="$(ogDiskToDev $3 $4)" || return $(ogRaiseError $OG_ERR_NOTFOUND " $3 $4"; echo $?)
#IMGTYPE=$(ogGetImageType "$1" "$2")
IMGTYPE=img
IMGFILE=$(ogGetPath "$1" "$2.$IMGTYPE") 
[ -r "$IMGFILE" ] || return $(ogRaiseError $OG_ERR_NOTFOUND " $3 $4"; echo $?)
# comprobamos consistencia de la imagen
ogGetImageInfo $IMGFILE >/dev/null  || return $(ogRaiseError $OG_ERR_IMAGE " $1 $2"; echo $?)

# Error si la imagen no cabe en la particion.
IMGSIZE=$(ogGetImageSize "$1" "$2") || return $(ogRaiseError $OG_ERR_IMAGE " $1 $2"; echo $?)
#TODO:
#Si la particion no esta formateado o tiene problemas formateamos
ogMount $3 $4 || ogFormat $3 $4
PARTSIZE=$(ogGetPartitionSize $3 $4)
if [ $IMGSIZE -gt $PARTSIZE ]; then
    ogRaiseError $OG_ERR_IMGSIZEPARTITION "  $PARTSIZE < $IMGSIZE"
    return $?
fi
# Comprobar el bloqueo de la imagen y de la partición.
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $1, $2.$IMGTYPE"
    return $?
fi
if ogIsLocked $3 $4; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION $3, $4"
    return $?
fi

# Solicitamos la generación de la instruccion a ejecutar
# Atención: no se comprueba el tipo de sistema de archivos.
# Atención: no se comprueba incongruencia entre partición e imagen.
PROGRAM=`ogRestoreImageSyntax  $IMGFILE $PART`

# Desmontar y bloquear partición.
ogUnmount $3 $4 2>/dev/null || return $(ogRaiseError $OG_ERR_PARTITION " $3 $4"; echo $?)
ogLock $3 $4 || return $?
trap "ogUnlock $3 $4" 1 2 3 6 9

# Ejecutar restauración según el tipo de imagen.
eval $PROGRAM

ERRCODE=$?
if [ $ERRCODE != 0 ]; then
    ogRaiseError $OG_ERR_IMAGE "$IMGFILE, $3, $4"
fi
ogUnlock $3 $4
return $ERRCODE
}


#/**
#         ogRestoreMbrImage str_repo path_image int_ndisk
#@brief   Restaura la imagen del sector de arranque de un disco.
#@param   str_repo     repositorio de imágenes o caché local
#@param   path_image   camino de la imagen
#@param   int_ndisk    nº de orden del disco
#@return  (por determinar)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND fichero de imagen o partición no detectados.
#@exception OG_ERR_IMAGE    error al restaurar la imagen del sistema.
#@version 0.9 - Primera versión en pruebas.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010/01/12
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogRestoreMbrImage ()
{
# Variables locales
local DISK IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str_repo path_image int_ndisk" \
           "$FUNCNAME REPO /aula1/mbr 1"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Procesar parámetros.
DISK=$(ogDiskToDev "$3") || return $?
IMGFILE=$(ogGetPath "$1" "$2.mbr")
[ -r "$IMGFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Restaurar imagen del MBR.
dd if="$IMGFILE" of="$DISK" bs=512 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}


#/**
#         ogRestoreBootLoaderImage str_repo path_image int_ndisk
#@brief   Restaura la imagen del boot loader del sector de arranque de un disco.
#@param   str_repo     repositorio de imágenes o caché local
#@param   path_image   camino de la imagen
#@param   int_ndisk    nº de orden del disco
#@return  (por determinar)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND fichero de imagen o partición no detectados.
#@exception OG_ERR_IMAGE    error al restaurar la imagen del sistema.
#@version 1.0 - Adaptacion de ogRestoreMbrImage para restaurar solo el Boot Loader
#@author  Juan Carlos Xifre, SICUZ Universidad de Zaragoza
#@date    2011/03/21
#*/ ##
function ogRestoreBootLoaderImage ()
{
# Variables locales
local DISK IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str_repo path_image int_ndisk" \
           "$FUNCNAME REPO /aula1/mbr 1"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Procesar parámetros.
DISK=$(ogDiskToDev "$3") || return $?
IMGFILE=$(ogGetPath "$1" "$2.mbr")
[ -r "$IMGFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Restaurar imagen del MBR.
dd if="$IMGFILE" of="$DISK" bs=446 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}

#/**
#         ogUnlockImage [str_repo] path_image
#@brief   Desbloquea una imagen con uso exclusivo.
#@param   str_repo     repositorio de imágenes (opcional)
#@param   path_image   camino de la imagen (sin extensión)
#@return  Nada.
#@note    repo = { REPO, CACHE }
#@note    Se elimina el fichero de bloqueo con extensión .lock
#@exception OG_ERR_FORMAT    formato incorrecto.
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogUnlockImage ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_repo] path_image" \
           "$FUNCNAME /opt/opengnsys/images/aula1/win7.img" \
           "$FUNCNAME REPO /aula1/win7.img"
    return
fi
# Error si no se reciben 1 o 2 parámetros.
[ $# == 1 -o $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Borrar fichero de bloqueo para la imagen.
rm -f $(ogGetPath $@.lock)
}


#/**
#         ogGetImageInfo filename
#@brief   muestra información sobre la imagen monolitica.
#@param 1   filename           path absoluto del fichero imagen
#@return  cadena compuesta por clonacion:compresor:sistemaarchivos:tamañoKB
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND   fichero no encontrado.
#@exception OG_ERR_IMAGE 	"Image format is not valid $IMGFILE"
#@warning En pruebas iniciales
#@TODO    Definir sintaxis de salida (herramienta y compresor en minuscula)
#@TODO 	  Arreglar loop para ntfsclone 
#@TODO    insertar parametros entrada tipo OG
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

function ogGetImageInfo ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_filename" \
           "$FUNCNAME /opt/opengnsys/images/prueba.img  ==>  PARTCLONE:LZOP:NTFS:5642158"
    return
fi

# Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#comprobando que el parametro uno es un file.
[ -f $1 ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?

local TOOLS COMPRESSOR IMGFILE FILEHEAD FS FSPLUS SIZE SIZEFACTOR PARTIMAGEINFO PARTCLONEINFO NTFSCLONEINFO IMGDETECT
IMGDETECT="FALSE"

IMGFILE=$1
FILEHEAD=/tmp/`basename $IMGFILE`.infohead
COMPRESSOR=`file $IMGFILE | awk '{print $2}'`
ogCheckStringInGroup "$COMPRESSOR" "gzip lzop" || ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $?
$($COMPRESSOR -dc $IMGFILE 2>/dev/null | head -n 40 > $FILEHEAD) || ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $?

## buscando Primera opción.
if [ "$IMGDETECT" == "FALSE" ] 
then 
	PARTCLONEINFO=$(LC_ALL=C partclone.info $FILEHEAD 2>&1)
	if `echo $PARTCLONEINFO | grep size > /dev/null`
	then
		TOOLS=PARTCLONE
		FS=$(echo $PARTCLONEINFO | awk '{gsub(/: /,"\n"); print toupper($8);}')
		if [[ "$FS" == "HFS" || "$FS" == "HFSPLUS" || "$FS" == "FAT32" ]]; then
			FSPLUS=$(echo $PARTCLONEINFO | awk '{gsub(/: /,"\n"); print toupper($9);}')
			echo $PARTCLONEINFO | grep GB > /dev/null && SIZEFACTOR=1000000 || SIZEFACTOR=1024
			if [ "$FSPLUS" == "PLUS" ]; then
				FS=$FS$FSPLUS
				SIZE=$(echo $PARTCLONEINFO | awk -v FACTOR=$SIZEFACTOR '{printf "%d\n", $17*FACTOR;}')
			else
				SIZE=$(echo $PARTCLONEINFO | awk -v FACTOR=$SIZEFACTOR '{printf "%d\n", $16*FACTOR;}')
			fi
		else
			echo $PARTCLONEINFO | grep GB > /dev/null && SIZEFACTOR=1000000 || SIZEFACTOR=1024
			SIZE=$(echo $PARTCLONEINFO | awk -v FACTOR=$SIZEFACTOR '{gsub(/: /,"\n"); printf "%d\n", $11*FACTOR;}')
		fi
		IMGDETECT="TRUE"
	fi
fi
#buscando segunda opcion.
if [ "$IMGDETECT" == "FALSE" -a ! -f /dev/loop2  ] 
then 
	cat $FILEHEAD | grep -w ntfsclone-image > /dev/null && NTFSCLONEINFO=$(cat $FILEHEAD | ntfsclone --restore --overwrite /dev/loop2 - 2>&1)
	if `echo $NTFSCLONEINFO | grep ntfsclone > /dev/null`  
	then
		TOOLS=NTFSCLONE
   		SIZE=$(echo $NTFSCLONEINFO | awk '{gsub(/\(|\)|\./,""); printf "%d\n",$17/1000;}')
   		FS=NTFS
   		IMGDETECT="TRUE"
	fi
fi
## buscando Tercer opción. 
if [ "$IMGDETECT" == "FALSE" ]
then
	PARTIMAGEINFO=$(partimage -B gui=no imginfo "$FILEHEAD" 2>&1)
	if `echo $PARTIMAGEINFO | grep Partition > /dev/null`
	then	
		TOOLS=PARTIMAGE	
		FS=$(echo $PARTIMAGEINFO | awk '{gsub(/ /,"\n"); print $17;}' | awk '{sub(/\.\.+/," "); print toupper($2)}') 
		SIZE=$( echo $PARTIMAGEINFO | awk '{gsub(/ /,"\n"); print $36;}' | awk '{sub(/\.\.+/," "); printf "%d\n",$2*1024*1024;}')
		IMGDETECT="TRUE"
	fi
	if file $FILEHEAD 2> /dev/null | grep -q "boot sector"; then
		TOOLS="partclone.dd"
                FS=
                SIZE=
		IMGDETECT="TRUE"
	fi
fi
#comprobamos valores #Chequeamos los valores devueltos.
if [ -z "$TOOLS" -o -z "$COMPRESSOR" -o "$IMGDETECT" == "FALSE" ]
then
	ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $?
else
	COMPRESSOR=$(echo $COMPRESSOR | tr [a-z] [A-Z])
	echo $TOOLS:$COMPRESSOR:$FS:$SIZE
fi
}

#/**
#         ogGetImageProgram str_REPO str_imagen
#@brief   muestra información sobre la imagen monolitica.
#@see     ogGetImageInfo
#@param 1   REPO o CACHE       contenedor de la imagen
#@param 2   filename           nombre de la imagen sin extension
#@return  nombre del programa usado para generar la imagen
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND   fichero no encontrado.
#@note     ogGetImageProgram REPO imagenA -> partclone
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

function ogGetImageProgram ()
{
local IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str_repo path_image" \
           "$FUNCNAME REPO prueba  ==>  PARTCLONE"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
IMGFILE=$(ogGetPath "$1" "$2.img")
[ -r "$IMGFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$IMGFILE" || return $?
ogGetImageInfo $IMGFILE | awk -F: '{print $1}'
}

#/**
#         ogGetImageCompressor str_REPO str_imagen
#@brief   muestra información sobre la imagen monolitica.
#@see     ogGetImageInfo
#@param 1   REPO o CACHE       contenedor de la imagen
#@param 2   filename           nombre de la imagen sin extension
#@return    tipo de compresión usada al generar la imagen
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND   fichero no encontrado.
#@note     ogGetImageCompressor REPO imagenA -> lzop
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##
function ogGetImageCompressor ()
{
local IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str_repo path_image" \
           "$FUNCNAME REPO prueba  ==>  LZOP"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
IMGFILE=$(ogGetPath "$1" "$2.img")
[ -r "$IMGFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$IMGFILE" || return $?
ogGetImageInfo $IMGFILE | awk -F: '{print $2}'
}


#/**
#         ogGetImageType str_REPO str_imagen
#@brief   muestra información sobre el sistema de archivos de imagen monolitica.
#@see     ogGetImageInfo
#@param 1   REPO o CACHE       contenedor de la imagen
#@param 2   filename           nombre de la imagen sin extension
#@return    tipo de compresión usada al generar la imagen
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND   fichero no encontrado.
#@note     ogGetImageType REPO imagenA -> NTFS
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##
function ogGetImageType ()
{
local IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str_repo path_image" \
           "$FUNCNAME REPO prueba  ==>  NTFS"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
IMGFILE=$(ogGetPath "$1" "$2.img")
[ -r "$IMGFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$IMGFILE" || return $?
ogGetImageInfo $IMGFILE | awk -F: '{print $3}'
}


#/**
#         ogGetImageSize str_REPO str_imagen
#@brief   muestra información sobre el tamaño (KB) del sistema de archivos de imagen monolitica.
#@see     ogGetImageInfo
#@param 1   REPO o CACHE       contenedor de la imagen
#@param 2   filename           nombre de la imagen sin extension
#@return    tipo de compresión usada al generar la imagen
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND   fichero no encontrado.
#@note     ogGetImagesize REPO imagenA -> 56432234  > Kb
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##
function ogGetImageSize ()
{
# Variables locales
local IMGFILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME str repo path_image" \
           "$FUNCNAME REPO prueba  ==>  5642158"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Error si el fichero de imagen no es accesible.
IMGFILE=$(ogGetPath "$1" "$2.img")
[ -r "$IMGFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Devuelve el tamaño de la imagen en KB.
ogGetImageInfo $IMGFILE | awk -F: '{print $4}'
}


#/**
#         ogCreateGptImage int_ndisk str_repo path_image
#@brief   Crea una imagen de la tabla de particiones GPT de un disco.
#@param   int_ndisk    nº de orden del disco
#@param   str_repo     repositorio de imágenes (remoto o caché local)
#@param   path_image   camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@version 1.1 - Adaptación a OpenGnSys 1.1
#@author  Juan Carlos Garcia. Universidad de Zaragoza
#@date    2017/03/29
#*/ ##
function ogCreateGptImage ()
{
# Variables locales
local DISK IMGDIR IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk path_dir str_image" \
           "$FUNCNAME 1 REPO /aula1/gpt"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?

DISK=$(ogDiskToDev "$1") || return $?
IMGDIR=$(ogGetParentPath "$2" "$3")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$2 $(dirname $3)" || return $?
IMGFILE="$IMGDIR/$(basename "$3").gpt"

# Crear imagen de la tabla GPT.
sgdisk -b="$IMGFILE" "$DISK" || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}

#/**
#         ogRestoreGptImage str_repo path_image int_ndisk
#@brief   Restaura la imagen de la tabla de particiones GPT de un disco.
#@param   str_repo     repositorio de imágenes o caché local
#@param   path_image   camino de la imagen
#@param   int_ndisk    nº de orden del disco
#@return  (por determinar)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND fichero de imagen o partición no detectados.
#@exception OG_ERR_IMAGE    error al restaurar la imagen del sistema.
#@version 1.1 - Adaptación a OpenGnSys 1.1
#@author  Juan Carlos Garcia, Universidad de Zaragoza
#@date    2017/03/29
#*/ ##
function ogRestoreGptImage ()
{
# Variables locales
local DISK IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_dir str_image int_ndisk" \
           "$FUNCNAME REPO /aula1/gpt 1"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Procesar parámetros.
DISK=$(ogDiskToDev "$3") || return $?
IMGFILE=$(ogGetPath "$1" "$2.gpt")
[ -r "$IMGFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Restaurar tabla GPT del disco.
sgdisk -l="$IMGFILE" "$DISK" || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}

